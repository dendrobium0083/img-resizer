# エラーハンドリング仕様書

## 文書情報

| 項目 | 内容 |
|------|------|
| 文書名 | エラーハンドリング仕様書 |
| プロジェクト名 | img-resizer |
| バージョン | 1.0.0 |
| 作成日 | 2024年 |
| 最終更新日 | 2024年 |
| 作成者 | - |
| 承認者 | - |
| 関連ドキュメント | [要件定義書](./要件定義書.md), [機能仕様書](./機能仕様書.md), [詳細設計書](./詳細設計書.md), [API仕様書](./API仕様書.md) |

---

## 1. 概要

### 1.1 目的

このドキュメントは、img-resizerプロジェクトにおけるエラーハンドリングの方針と実装仕様を定義します。エラー発生時の処理方法、エラーコード体系、ログ出力方針、例外処理の実装方針を明確化します。

### 1.2 対象読者

- 開発者
- コードレビュアー
- テスター
- 運用担当者

### 1.3 エラーハンドリングの基本方針

1. **明確なエラー情報の提供**: エラーコードとメッセージでエラー内容を明確に伝える
2. **適切なHTTPステータスコード**: エラーの種類に応じた適切なHTTPステータスコードを返却
3. **ログ記録**: すべてのエラーをログに記録し、デバッグと運用監視を支援
4. **セキュリティ**: 機密情報をエラーメッセージに含めない
5. **ユーザーフレンドリー**: 技術的な詳細を隠し、ユーザーに分かりやすいメッセージを提供

---

## 2. エラー分類

### 2.1 エラーの種類

エラーは以下の4つのカテゴリに分類されます：

| カテゴリ | 説明 | HTTPステータス | 例 |
|---------|------|---------------|-----|
| **クライアントエラー** | リクエストが不正または処理できない | 400, 404 | ファイルが見つからない、無効なパラメータ |
| **バリデーションエラー** | リクエストの検証に失敗 | 400 | ファイルパスが空、無効な拡張子 |
| **サーバーエラー** | サーバー側の問題によるエラー | 500 | ファイル読み書きエラー、設定エラー |
| **予期しないエラー** | 予期しない例外が発生 | 500 | 未処理の例外、システムエラー |

### 2.2 エラーの発生箇所

| 発生箇所 | エラーの種類 | 処理方法 |
|---------|------------|----------|
| **リクエストバリデーション** | バリデーションエラー | `ValidationException`をスロー |
| **ファイル存在確認** | クライアントエラー | `FileNotFoundException`をスロー |
| **ファイル読み込み** | サーバーエラー | `FileReadException`をスロー |
| **画像変換処理** | サーバーエラー | `ImageProcessingException`をスロー |
| **ファイル書き込み** | サーバーエラー | `FileWriteException`をスロー |
| **設定読み込み** | サーバーエラー | `ConfigurationException`をスロー |
| **予期しない例外** | 予期しないエラー | `INTERNAL_SERVER_ERROR`を返却 |

---

## 3. エラーコード体系

### 3.1 エラーコード命名規則

- **形式**: `UPPER_SNAKE_CASE`
- **命名規則**: エラーの種類を表す明確な名前
- **例**: `FILE_NOT_FOUND`, `INVALID_FILE_FORMAT`

### 3.2 エラーコード一覧

| エラーコード | 説明 | HTTPステータス | 発生条件 | カテゴリ |
|------------|------|---------------|----------|---------|
| `FILE_NOT_FOUND` | ファイルが見つからない | 404 | 指定されたファイルパスにファイルが存在しない | クライアントエラー |
| `INVALID_FILE_FORMAT` | サポートされていない画像形式 | 400 | ファイルの拡張子が許可リストに含まれていない | バリデーションエラー |
| `FILE_READ_ERROR` | ファイル読み込みエラー | 500 | ファイルの読み込みに失敗した（権限不足、ファイル破損等） | サーバーエラー |
| `FILE_WRITE_ERROR` | ファイル書き込みエラー | 500 | ファイルの書き込みに失敗した（権限不足、ディスク容量不足等） | サーバーエラー |
| `FILE_TOO_LARGE` | ファイルサイズが大きすぎる | 400 | ファイルサイズが最大制限（50MB）を超えている | バリデーションエラー |
| `INVALID_CONFIGURATION` | 設定ファイルが不正 | 500 | 設定ファイルの値が無効または不足している | サーバーエラー |
| `INVALID_REQUEST` | リクエストが不正 | 400 | リクエストパラメータが不正（ファイルパスが空、resizeModeが無効等） | バリデーションエラー |
| `IMAGE_LOAD_ERROR` | 画像の読み込みに失敗 | 500 | 画像データが破損している、画像形式が不正 | サーバーエラー |
| `IMAGE_PROCESSING_ERROR` | 画像処理エラー | 500 | 画像変換処理中にエラーが発生 | サーバーエラー |
| `INTERNAL_SERVER_ERROR` | サーバー内部エラー | 500 | 予期しないエラーが発生した | 予期しないエラー |

### 3.3 エラーコードの追加方針

新しいエラーコードを追加する際は、以下の点を考慮します：

1. **既存のエラーコードで対応できないか確認**
2. **エラーコード名が明確で一意であること**
3. **適切なHTTPステータスコードを選択**
4. **ドキュメントを更新**

---

## 4. エラーレスポンス形式

### 4.1 エラーレスポンススキーマ

**エラーレスポンス（JSON形式）**:
```json
{
  "success": false,
  "message": "エラーメッセージ",
  "errorCode": "ERROR_CODE"
}
```

### 4.2 レスポンスフィールド

| フィールド名 | 型 | 必須 | 説明 |
|------------|-----|------|------|
| `success` | boolean | 必須 | 常に`false` |
| `message` | string | 必須 | エラーメッセージ（ユーザー向け） |
| `errorCode` | string | 必須 | エラーコード（開発者向け） |

### 4.3 エラーレスポンス例

#### 4.3.1 ファイルが見つからない場合

**HTTPステータス**: `404 Not Found`

**レスポンス**:
```json
{
  "success": false,
  "message": "ファイルが見つかりません: C:\\images\\input\\photo.jpg",
  "errorCode": "FILE_NOT_FOUND"
}
```

#### 4.3.2 無効な拡張子の場合

**HTTPステータス**: `400 Bad Request`

**レスポンス**:
```json
{
  "success": false,
  "message": "サポートされていない画像形式です: .pdf",
  "errorCode": "INVALID_FILE_FORMAT"
}
```

#### 4.3.3 ファイルサイズ超過の場合

**HTTPステータス**: `400 Bad Request`

**レスポンス**:
```json
{
  "success": false,
  "message": "ファイルサイズが大きすぎます。最大サイズは50MBです。",
  "errorCode": "FILE_TOO_LARGE"
}
```

#### 4.3.4 リクエストが不正な場合

**HTTPステータス**: `400 Bad Request`

**レスポンス**:
```json
{
  "success": false,
  "message": "ファイルパスが指定されていません",
  "errorCode": "INVALID_REQUEST"
}
```

#### 4.3.5 サーバーエラーの場合

**HTTPステータス**: `500 Internal Server Error`

**レスポンス**:
```json
{
  "success": false,
  "message": "サーバーエラーが発生しました",
  "errorCode": "FILE_READ_ERROR"
}
```

### 4.4 エラーメッセージのガイドライン

1. **明確性**: エラーの原因を明確に示す
2. **簡潔性**: 必要最小限の情報を含める
3. **ユーザーフレンドリー**: 技術的な詳細を隠し、ユーザーに分かりやすい表現を使用
4. **セキュリティ**: 機密情報（ファイルパス、スタックトレース等）を本番環境では含めない
5. **一貫性**: 同じエラーに対して常に同じメッセージを返す

---

## 5. カスタム例外クラス

### 5.1 例外クラス階層

```
Exception
  └─ ImageProcessingException (基底クラス)
      ├─ FileNotFoundException
      ├─ UnsupportedFormatException
      ├─ FileTooLargeException
      ├─ ValidationException
      ├─ FileReadException
      ├─ FileWriteException
      ├─ ImageLoadException
      ├─ ImageProcessingException
      └─ ConfigurationException
```

### 5.2 基底例外クラス

**名前空間**: `ImgResizer.Domain.Exceptions`

```csharp
namespace ImgResizer.Domain.Exceptions;

public class ImageProcessingException : Exception
{
    public string ErrorCode { get; }

    public ImageProcessingException(string errorCode, string message) 
        : base(message)
    {
        ErrorCode = errorCode;
    }

    public ImageProcessingException(string errorCode, string message, Exception innerException) 
        : base(message, innerException)
    {
        ErrorCode = errorCode;
    }
}
```

### 5.3 カスタム例外クラス一覧

#### 5.3.1 FileNotFoundException

```csharp
public class FileNotFoundException : ImageProcessingException
{
    public FileNotFoundException(string filePath) 
        : base("FILE_NOT_FOUND", $"ファイルが見つかりません: {filePath}")
    {
    }
}
```

#### 5.3.2 UnsupportedFormatException

```csharp
public class UnsupportedFormatException : ImageProcessingException
{
    public UnsupportedFormatException(string extension) 
        : base("INVALID_FILE_FORMAT", $"サポートされていない画像形式です: {extension}")
    {
    }
}
```

#### 5.3.3 FileTooLargeException

```csharp
public class FileTooLargeException : ImageProcessingException
{
    public FileTooLargeException(long fileSize, long maxSize) 
        : base("FILE_TOO_LARGE", 
            $"ファイルサイズが大きすぎます。現在: {FormatFileSize(fileSize)}、最大: {FormatFileSize(maxSize)}")
    {
    }

    private static string FormatFileSize(long bytes)
    {
        // ファイルサイズを読みやすい形式に変換（例: "50MB"）
        return $"{bytes / 1024 / 1024}MB";
    }
}
```

#### 5.3.4 ValidationException

```csharp
public class ValidationException : ImageProcessingException
{
    public ValidationException(string message) 
        : base("INVALID_REQUEST", message)
    {
    }
}
```

#### 5.3.5 FileReadException

```csharp
public class FileReadException : ImageProcessingException
{
    public FileReadException(string filePath, Exception innerException) 
        : base("FILE_READ_ERROR", 
            $"ファイルの読み込みに失敗しました: {filePath}", 
            innerException)
    {
    }
}
```

#### 5.3.6 FileWriteException

```csharp
public class FileWriteException : ImageProcessingException
{
    public FileWriteException(string filePath, Exception innerException) 
        : base("FILE_WRITE_ERROR", 
            $"ファイルの書き込みに失敗しました: {filePath}", 
            innerException)
    {
    }
}
```

#### 5.3.7 ImageLoadException

```csharp
public class ImageLoadException : ImageProcessingException
{
    public ImageLoadException(string filePath, Exception innerException) 
        : base("IMAGE_LOAD_ERROR", 
            $"画像の読み込みに失敗しました: {filePath}", 
            innerException)
    {
    }
}
```

#### 5.3.8 ImageProcessingException（画像処理エラー）

```csharp
public class ImageProcessingException : ImageProcessingException
{
    public ImageProcessingException(string message, Exception innerException) 
        : base("IMAGE_PROCESSING_ERROR", 
            $"画像処理中にエラーが発生しました: {message}", 
            innerException)
    {
    }
}
```

#### 5.3.9 ConfigurationException

```csharp
public class ConfigurationException : ImageProcessingException
{
    public ConfigurationException(string message) 
        : base("INVALID_CONFIGURATION", $"設定が不正です: {message}")
    {
    }
}
```

---

## 6. 例外処理の実装方針

### 6.1 レイヤー別の例外処理

#### 6.1.1 Domain層

**責務**: カスタム例外クラスの定義

- ビジネスルール違反時にカスタム例外をスロー
- 他のレイヤーに依存しない例外クラスを定義

**例**:
```csharp
// Domain層での例外スロー
if (!File.Exists(filePath))
{
    throw new FileNotFoundException(filePath);
}
```

#### 6.1.2 Application層

**責務**: ビジネスロジックの実行と例外のスロー

- ユースケースの実行中に例外をスロー
- Domain層の例外をそのまま再スロー、または新しい例外にラップ

**例**:
```csharp
public async Task<ResizeImageResponse> ExecuteAsync(ResizeImageRequest request)
{
    try
    {
        // バリデーション
        if (string.IsNullOrWhiteSpace(request.FilePath))
        {
            throw new ValidationException("ファイルパスが指定されていません");
        }

        // ファイル存在確認
        if (!_imageRepository.FileExists(request.FilePath))
        {
            throw new FileNotFoundException(request.FilePath);
        }

        // 処理実行...
    }
    catch (ImageProcessingException)
    {
        // Domain層の例外はそのまま再スロー
        throw;
    }
    catch (Exception ex)
    {
        // 予期しない例外はラップ
        throw new ImageProcessingException("INTERNAL_SERVER_ERROR", 
            "予期しないエラーが発生しました", ex);
    }
}
```

#### 6.1.3 Infrastructure層

**責務**: 外部リソースへのアクセス時の例外処理

- ファイルシステム、外部ライブラリの例外をカスタム例外に変換
- 内部例外を保持してラップ

**例**:
```csharp
public async Task<byte[]> ReadImageAsync(string filePath)
{
    try
    {
        return await File.ReadAllBytesAsync(filePath);
    }
    catch (FileNotFoundException ex)
    {
        throw new FileNotFoundException(filePath);
    }
    catch (UnauthorizedAccessException ex)
    {
        throw new FileReadException(filePath, ex);
    }
    catch (Exception ex)
    {
        throw new FileReadException(filePath, ex);
    }
}
```

#### 6.1.4 Presentation層

**責務**: 例外のキャッチとHTTPレスポンスへの変換

- すべての例外をキャッチ
- 適切なHTTPステータスコードとエラーレスポンスを返却
- ログに記録

**例**:
```csharp
[HttpPost("resize")]
public async Task<ActionResult<ResizeImageResponse>> ResizeImage(
    [FromBody] ResizeImageRequest request)
{
    try
    {
        var response = await _resizeImageUseCase.ExecuteAsync(request);
        return Ok(response);
    }
    catch (ImageProcessingException ex)
    {
        return HandleImageProcessingException(ex);
    }
    catch (Exception ex)
    {
        return HandleUnexpectedException(ex);
    }
}
```

### 6.2 例外処理フロー

```
[Domain層]
  |
  | カスタム例外をスロー
  | (例: FileNotFoundException)
  |
  v
[Application層]
  |
  | 例外をキャッチまたは再スロー
  | 必要に応じてラップ
  |
  v
[Infrastructure層]
  |
  | 外部例外をカスタム例外に変換
  | (例: FileNotFoundException → FileReadException)
  |
  v
[Presentation層]
  |
  | 例外をキャッチ
  | HTTPステータスコードを決定
  | エラーレスポンスを生成
  | ログに記録
  |
  v
[Client]
  |
  | HTTPレスポンス（エラー）
  |
```

---

## 7. グローバルエラーハンドラー

### 7.1 グローバルエラーハンドラーの実装

ASP.NET Coreのミドルウェアを使用してグローバルエラーハンドラーを実装します。

**実装例**:
```csharp
// Program.cs
app.UseExceptionHandler(errorApp =>
{
    errorApp.Run(async context =>
    {
        context.Response.StatusCode = 500;
        context.Response.ContentType = "application/json";

        var exceptionHandlerPathFeature = context.Features.Get<IExceptionHandlerPathFeature>();
        var exception = exceptionHandlerPathFeature?.Error;

        var response = new ResizeImageResponse
        {
            Success = false,
            Message = "サーバーエラーが発生しました",
            ErrorCode = "INTERNAL_SERVER_ERROR"
        };

        // カスタム例外の処理
        if (exception is ImageProcessingException imageEx)
        {
            response.ErrorCode = imageEx.ErrorCode;
            response.Message = imageEx.Message;
            context.Response.StatusCode = GetStatusCode(imageEx.ErrorCode);
        }

        // ログ記録
        var logger = context.RequestServices.GetRequiredService<ILogger<Program>>();
        logger.LogError(exception, "エラーが発生しました: {ErrorCode}", response.ErrorCode);

        var json = JsonSerializer.Serialize(response);
        await context.Response.WriteAsync(json);
    });
});
```

### 7.2 HTTPステータスコードの決定

```csharp
private static int GetStatusCode(string errorCode)
{
    return errorCode switch
    {
        "FILE_NOT_FOUND" => 404,
        "INVALID_FILE_FORMAT" => 400,
        "FILE_TOO_LARGE" => 400,
        "INVALID_REQUEST" => 400,
        "FILE_READ_ERROR" => 500,
        "FILE_WRITE_ERROR" => 500,
        "INVALID_CONFIGURATION" => 500,
        "IMAGE_LOAD_ERROR" => 500,
        "IMAGE_PROCESSING_ERROR" => 500,
        _ => 500
    };
}
```

---

## 8. ログ出力方針

### 8.1 ログレベル

| ログレベル | 用途 | 出力内容 |
|-----------|------|----------|
| **Error** | エラー発生時 | 例外情報、エラーコード、スタックトレース |
| **Warning** | 警告 | 設定値のデフォルト使用、バリデーション警告 |
| **Information** | 正常な処理完了 | リクエスト受信、処理完了 |
| **Debug** | デバッグ情報 | 詳細な処理情報（開発環境のみ） |

### 8.2 エラーログの出力内容

エラー発生時には以下の情報をログに記録します：

1. **エラーコード**
2. **エラーメッセージ**
3. **例外の種類**
4. **スタックトレース**（開発環境のみ、またはErrorレベル）
5. **リクエスト情報**（ファイルパス、resizeMode等）
6. **タイムスタンプ**

### 8.3 ログ出力例

#### 8.3.1 ファイルが見つからない場合

```csharp
_logger.LogWarning(
    "ファイルが見つかりません: {FilePath}, ErrorCode: {ErrorCode}",
    request.FilePath,
    "FILE_NOT_FOUND");
```

**ログ出力**:
```
[2024-01-01 12:00:00] WARNING: ファイルが見つかりません: C:\images\input\photo.jpg, ErrorCode: FILE_NOT_FOUND
```

#### 8.3.2 ファイル読み込みエラーの場合

```csharp
_logger.LogError(ex,
    "ファイル読み込みエラー: {FilePath}, ErrorCode: {ErrorCode}",
    filePath,
    "FILE_READ_ERROR");
```

**ログ出力**:
```
[2024-01-01 12:00:00] ERROR: ファイル読み込みエラー: C:\images\input\photo.jpg, ErrorCode: FILE_READ_ERROR
System.UnauthorizedAccessException: アクセスが拒否されました。
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share)
   ...
```

#### 8.3.3 予期しないエラーの場合

```csharp
_logger.LogError(ex,
    "予期しないエラーが発生しました: {FilePath}, ErrorCode: {ErrorCode}",
    request.FilePath,
    "INTERNAL_SERVER_ERROR");
```

**ログ出力**:
```
[2024-01-01 12:00:00] ERROR: 予期しないエラーが発生しました: C:\images\input\photo.jpg, ErrorCode: INTERNAL_SERVER_ERROR
System.NullReferenceException: オブジェクト参照がオブジェクト インスタンスに設定されていません。
   at ImgResizer.Application.UseCases.ResizeImageUseCase.ExecuteAsync(ResizeImageRequest request)
   ...
```

### 8.4 ログ設定

本プロジェクトでは、構造化ログを実現するため**Serilog**を使用しています。

**appsettings.json**:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "ImgResizer": "Debug"
    }
  },
  "Serilog": {
    "Using": [ "Serilog.Sinks.Console", "Serilog.Sinks.File" ],
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Microsoft.AspNetCore": "Warning",
        "ImgResizer": "Debug"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/img-resizer-.log",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 30,
          "fileSizeLimitBytes": 104857600,
          "rollOnFileSizeLimit": true
        }
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/img-resizer-errors-.log",
          "rollingInterval": "Day",
          "restrictedToMinimumLevel": "Error",
          "retainedFileCountLimit": 90
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId", "WithProcessId" ]
  }
}
```

**appsettings.Development.json**:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information",
      "ImgResizer": "Debug"
    }
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "ImgResizer": "Verbose"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {SourceContext}{NewLine}  {Message:lj}{NewLine}  {Properties:j}{NewLine}{Exception}"
        }
      },
      {
        "Name": "Seq",
        "Args": {
          "serverUrl": "http://localhost:5341"
        }
      }
    ]
  }
}
```

**ログ出力先**:
- **コンソール**: 開発時の確認用
- **ファイル**: `logs/img-resizer-{日付}.log`（全ログ、30日保持）
- **エラーログファイル**: `logs/img-resizer-errors-{日付}.log`（エラーレベルのみ、90日保持）
- **Seq**（開発環境のみ）: リアルタイムログ確認用（http://localhost:5341）

**ログエンリッチャー**:
- `FromLogContext`: コンテキスト情報の追加
- `WithMachineName`: マシン名
- `WithThreadId`: スレッドID
- `WithProcessId`: プロセスID

### 8.5 ログ出力のベストプラクティス

1. **構造化ログ**: パラメータを構造化して記録（例: `{FilePath}`, `{ErrorCode}`）
2. **機密情報の保護**: パスワード、トークン等の機密情報をログに含めない
3. **適切なログレベル**: エラーの重要度に応じたログレベルを選択
4. **コンテキスト情報**: エラー発生時のコンテキスト（リクエスト情報等）を含める
5. **パフォーマンス**: ログ出力がパフォーマンスに影響を与えないよう注意

---

## 9. エラーハンドリングの実装例

### 9.1 コントローラーでのエラーハンドリング

```csharp
[ApiController]
[Route("api/[controller]")]
public class ImageController : ControllerBase
{
    private readonly ResizeImageUseCase _resizeImageUseCase;
    private readonly ILogger<ImageController> _logger;

    public ImageController(
        ResizeImageUseCase resizeImageUseCase,
        ILogger<ImageController> logger)
    {
        _resizeImageUseCase = resizeImageUseCase;
        _logger = logger;
    }

    [HttpPost("resize")]
    public async Task<ActionResult<ResizeImageResponse>> ResizeImage(
        [FromBody] ResizeImageRequest request)
    {
        try
        {
            _logger.LogInformation("画像変換リクエスト受信: {FilePath}, ResizeMode: {ResizeMode}",
                request.FilePath, request.ResizeMode ?? "fit");

            var response = await _resizeImageUseCase.ExecuteAsync(request);

            if (response.Success)
            {
                _logger.LogInformation("画像変換処理完了: {OutputPath}", response.OutputPath);
                return Ok(response);
            }

            _logger.LogWarning("画像変換処理失敗: {ErrorCode}, {Message}",
                response.ErrorCode, response.Message);
            return BadRequest(response);
        }
        catch (FileNotFoundException ex)
        {
            _logger.LogWarning(ex, "ファイルが見つかりません: {FilePath}", request.FilePath);
            return NotFound(new ResizeImageResponse
            {
                Success = false,
                Message = ex.Message,
                ErrorCode = ex.ErrorCode
            });
        }
        catch (ValidationException ex)
        {
            _logger.LogWarning(ex, "バリデーションエラー: {Message}", ex.Message);
            return BadRequest(new ResizeImageResponse
            {
                Success = false,
                Message = ex.Message,
                ErrorCode = ex.ErrorCode
            });
        }
        catch (UnsupportedFormatException ex)
        {
            _logger.LogWarning(ex, "サポートされていない画像形式: {Message}", ex.Message);
            return BadRequest(new ResizeImageResponse
            {
                Success = false,
                Message = ex.Message,
                ErrorCode = ex.ErrorCode
            });
        }
        catch (FileTooLargeException ex)
        {
            _logger.LogWarning(ex, "ファイルサイズ超過: {Message}", ex.Message);
            return BadRequest(new ResizeImageResponse
            {
                Success = false,
                Message = ex.Message,
                ErrorCode = ex.ErrorCode
            });
        }
        catch (ImageProcessingException ex)
        {
            _logger.LogError(ex, "画像処理エラー: {ErrorCode}, {Message}",
                ex.ErrorCode, ex.Message);
            return StatusCode(500, new ResizeImageResponse
            {
                Success = false,
                Message = ex.Message,
                ErrorCode = ex.ErrorCode
            });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "予期しないエラーが発生しました: {FilePath}", request.FilePath);
            return StatusCode(500, new ResizeImageResponse
            {
                Success = false,
                Message = "サーバーエラーが発生しました",
                ErrorCode = "INTERNAL_SERVER_ERROR"
            });
        }
    }
}
```

### 9.2 ユースケースでのエラーハンドリング

```csharp
public class ResizeImageUseCase
{
    private readonly IImageRepository _imageRepository;
    private readonly IImageResizeService _imageResizeService;
    private readonly IOptions<ImageResizeSettings> _settings;
    private readonly ILogger<ResizeImageUseCase> _logger;

    public async Task<ResizeImageResponse> ExecuteAsync(ResizeImageRequest request)
    {
        try
        {
            // バリデーション
            ValidateRequest(request);

            // ファイル存在確認
            if (!_imageRepository.FileExists(request.FilePath))
            {
                throw new FileNotFoundException(request.FilePath);
            }

            // 拡張子チェック
            var extension = Path.GetExtension(request.FilePath).ToLower();
            if (!_settings.Value.AllowedExtensions.Contains(extension))
            {
                throw new UnsupportedFormatException(extension);
            }

            // ファイルサイズチェック
            var fileInfo = new FileInfo(request.FilePath);
            if (fileInfo.Length > _settings.Value.MaxFileSize)
            {
                throw new FileTooLargeException(fileInfo.Length, _settings.Value.MaxFileSize);
            }

            // 画像読み込み
            byte[] imageData;
            try
            {
                imageData = await _imageRepository.ReadImageAsync(request.FilePath);
            }
            catch (Exception ex)
            {
                throw new FileReadException(request.FilePath, ex);
            }

            // 画像変換
            var resizeMode = request.ResizeMode ?? "fit";
            byte[] resizedImageData;
            try
            {
                resizedImageData = await _imageResizeService.ResizeToSquareAsync(
                    imageData, 
                    _settings.Value.TargetSize.Width, 
                    resizeMode);
            }
            catch (Exception ex)
            {
                throw new ImageProcessingException("画像変換処理に失敗しました", ex);
            }

            // 出力パス生成
            var outputPath = _imageRepository.GetOutputPath(
                request.FilePath, 
                _settings.Value.OutputDirectory, 
                resizeMode);

            // 画像保存
            try
            {
                await _imageRepository.SaveImageAsync(outputPath, resizedImageData);
            }
            catch (Exception ex)
            {
                throw new FileWriteException(outputPath, ex);
            }

            return new ResizeImageResponse
            {
                Success = true,
                Message = "画像を512×512に変換しました",
                OutputPath = outputPath,
                ResizeMode = resizeMode
            };
        }
        catch (ImageProcessingException)
        {
            // Domain層の例外はそのまま再スロー
            throw;
        }
        catch (Exception ex)
        {
            // 予期しない例外はラップ
            _logger.LogError(ex, "予期しないエラーが発生しました");
            throw new ImageProcessingException("INTERNAL_SERVER_ERROR",
                "予期しないエラーが発生しました", ex);
        }
    }

    private void ValidateRequest(ResizeImageRequest request)
    {
        if (string.IsNullOrWhiteSpace(request.FilePath))
        {
            throw new ValidationException("ファイルパスが指定されていません");
        }

        // パストラバーサルチェック
        if (request.FilePath.Contains("..") || request.FilePath.Contains("~"))
        {
            throw new ValidationException("無効なファイルパスです");
        }

        // resizeModeの検証
        var validModes = new[] { "fit", "crop" };
        var resizeMode = request.ResizeMode ?? "fit";
        if (!validModes.Contains(resizeMode.ToLower()))
        {
            throw new ValidationException(
                $"無効な変換方式です: {resizeMode}。有効な値は 'fit' または 'crop' です。");
        }
    }
}
```

---

## 10. リトライ・フォールバック戦略

### 10.1 リトライ戦略

現時点では、リトライ機能は実装されていません。将来的に以下のケースでリトライを検討します：

- **一時的なファイルI/Oエラー**: ネットワークドライブへのアクセス失敗時
- **外部サービス呼び出し**: 将来的に外部サービスを呼び出す場合

### 10.2 フォールバック戦略

現時点では、フォールバック機能は実装されていません。将来的に以下のケースでフォールバックを検討します：

- **設定値のデフォルト使用**: 設定ファイルが不正な場合、デフォルト値を使用
- **画像形式の自動変換**: サポートされていない形式の場合、代替形式に変換

---

## 11. エラーハンドリングのベストプラクティス

### 11.1 例外のスロー

1. **適切な例外タイプを使用**: カスタム例外クラスを使用してエラーの種類を明確にする
2. **意味のあるメッセージ**: エラーの原因を明確に示すメッセージを含める
3. **内部例外の保持**: 元の例外情報を保持するため、`innerException`を使用
4. **早期リターン**: エラーが発生したら早期に例外をスロー

### 11.2 例外のキャッチ

1. **具体的な例外を先にキャッチ**: より具体的な例外クラスを先にキャッチ
2. **予期しない例外の処理**: すべての例外をキャッチし、適切に処理
3. **ログ記録**: 例外発生時は必ずログに記録
4. **リソースの解放**: `using`ステートメントや`finally`ブロックでリソースを適切に解放

### 11.3 エラーメッセージ

1. **ユーザーフレンドリー**: 技術的な詳細を隠し、ユーザーに分かりやすい表現を使用
2. **明確性**: エラーの原因と対処方法を明確に示す
3. **一貫性**: 同じエラーに対して常に同じメッセージを返す
4. **セキュリティ**: 機密情報をエラーメッセージに含めない

### 11.4 ログ記録

1. **構造化ログ**: パラメータを構造化して記録
2. **適切なログレベル**: エラーの重要度に応じたログレベルを選択
3. **コンテキスト情報**: エラー発生時のコンテキストを含める
4. **パフォーマンス**: ログ出力がパフォーマンスに影響を与えないよう注意

---

## 12. Resultパターンによるエラーハンドリング

### 12.1 Resultパターンの概要

**実装日**: 2025年12月1日

img-resizerプロジェクトでは、例外駆動のエラーハンドリングからResultパターンによるエラーハンドリングに移行しました。Resultパターンは、正常系と異常系を明示的に表現し、例外のパフォーマンスオーバーヘッドを削減するモダンな設計パターンです。

### 12.2 Resultパターンのメリット

1. **パフォーマンス向上**: 例外のスタックトレース生成のオーバーヘッドを削減
2. **明示的なフロー制御**: 成功と失敗が明確に分離される
3. **可読性の向上**: エラーハンドリングのロジックが明確になる
4. **テスタビリティの向上**: 例外を使わないためモックが容易

### 12.3 Resultクラスの実装

#### Result基底クラス（値なし）

```csharp
// ImgResizer.Domain/Common/Result.cs
public class Result
{
    public bool IsSuccess { get; }
    public bool IsFailure => !IsSuccess;
    public string ErrorCode { get; }
    public string ErrorMessage { get; }

    protected Result(bool isSuccess, string errorCode, string errorMessage)
    {
        // バリデーションロジック
        IsSuccess = isSuccess;
        ErrorCode = errorCode ?? string.Empty;
        ErrorMessage = errorMessage ?? string.Empty;
    }

    public static Result Success() => new(true, string.Empty, string.Empty);
    public static Result Failure(string errorCode, string errorMessage) 
        => new(false, errorCode, errorMessage);
    public static Result<T> Success<T>(T value) => new(value, true, string.Empty, string.Empty);
    public static Result<T> Failure<T>(string errorCode, string errorMessage) 
        => new(default!, false, errorCode, errorMessage);
}
```

#### Result<T>クラス（値あり）

```csharp
public class Result<T> : Result
{
    public T Value { get; }

    protected internal Result(T value, bool isSuccess, string errorCode, string errorMessage)
        : base(isSuccess, errorCode, errorMessage)
    {
        Value = value;
    }
}
```

### 12.4 使用方法

#### Infrastructure層での使用例

```csharp
// ファイル読み込み（成功時）
public async Task<Result<byte[]>> ReadImageAsync(string filePath)
{
    try
    {
        if (!File.Exists(filePath))
        {
            return Result.Failure<byte[]>(
                "FILE_NOT_FOUND",
                $"ファイルが見つかりません: {filePath}");
        }

        var data = await File.ReadAllBytesAsync(filePath);
        return Result.Success(data);
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "ファイル読み込みエラー: {FilePath}", filePath);
        return Result.Failure<byte[]>(
            "FILE_READ_ERROR",
            $"ファイルの読み込みに失敗しました: {ex.Message}");
    }
}
```

#### Application層での使用例

```csharp
public async Task<Result<ResizeImageResponse>> ExecuteAsync(ResizeImageRequest request)
{
    // バリデーション
    var validationResult = ValidateRequest(request);
    if (validationResult.IsFailure)
    {
        return Result.Failure<ResizeImageResponse>(
            validationResult.ErrorCode, 
            validationResult.ErrorMessage);
    }

    // 画像読み込み
    var imageDataResult = await _imageRepository.ReadImageAsync(request.FilePath);
    if (imageDataResult.IsFailure)
    {
        return Result.Failure<ResizeImageResponse>(
            imageDataResult.ErrorCode,
            imageDataResult.ErrorMessage);
    }

    // 画像変換
    var resizedImageDataResult = await _imageResizeService.ResizeToSquareAsync(...);
    if (resizedImageDataResult.IsFailure)
    {
        return Result.Failure<ResizeImageResponse>(
            resizedImageDataResult.ErrorCode,
            resizedImageDataResult.ErrorMessage);
    }

    // 成功レスポンス
    return Result.Success(new ResizeImageResponse
    {
        Success = true,
        Message = "画像を512×512に変換しました",
        OutputPath = outputPath,
        ResizeMode = resizeMode
    });
}
```

#### Presentation層（Controller）での使用例

```csharp
[HttpPost("resize")]
public async Task<ActionResult<ResizeImageResponse>> ResizeImage(
    [FromBody] ResizeImageRequest request)
{
    var result = await _resizeImageUseCase.ExecuteAsync(request);

    if (result.IsSuccess)
    {
        return Ok(result.Value);
    }

    // エラーコードに基づいてHTTPステータスコードを決定
    return result.ErrorCode switch
    {
        "FILE_NOT_FOUND" => NotFound(CreateErrorResponse(result)),
        "VALIDATION_ERROR" => BadRequest(CreateErrorResponse(result)),
        "UNSUPPORTED_FORMAT" => BadRequest(CreateErrorResponse(result)),
        "FILE_TOO_LARGE" => BadRequest(CreateErrorResponse(result)),
        "IMAGE_PROCESSING_ERROR" => StatusCode(500, CreateErrorResponse(result)),
        _ => StatusCode(500, CreateErrorResponse(result))
    };
}
```

### 12.5 エラーコードのマッピング

Resultパターンで使用されるエラーコードと、対応するHTTPステータスコードのマッピング：

| エラーコード | HTTPステータス | 発生箇所 | 説明 |
|------------|---------------|---------|------|
| `FILE_NOT_FOUND` | 404 | Repository | ファイルが見つからない |
| `VALIDATION_ERROR` | 400 | UseCase | バリデーションエラー |
| `UNSUPPORTED_FORMAT` | 400 | UseCase | サポートされていない画像形式 |
| `FILE_TOO_LARGE` | 400 | UseCase | ファイルサイズ超過 |
| `FILE_READ_ERROR` | 500 | Repository | ファイル読み込みエラー |
| `FILE_WRITE_ERROR` | 500 | Repository | ファイル書き込みエラー |
| `IMAGE_LOAD_ERROR` | 400 | Service | 画像データの読み込みエラー |
| `IMAGE_PROCESSING_ERROR` | 500 | Service | 画像処理エラー |
| `INTERNAL_SERVER_ERROR` | 500 | UseCase | 予期しないエラー |

### 12.6 例外との併用

Resultパターンを導入しましたが、以下の場合は引き続き例外を使用します：

1. **予期しないシステムエラー**: OutOfMemoryException、StackOverflowExceptionなど
2. **設定エラー**: アプリケーション起動時の設定検証エラー
3. **フレームワークレベルのエラー**: ASP.NET Coreの内部エラー

これらの例外は、UseCase層で適切にキャッチしてResultに変換します。

### 12.7 実装の影響範囲

Resultパターンの導入により、以下のコードが変更されました：

#### Domain層
- `Result.cs` および `Result<T>.cs` を新規作成
- `IImageRepository.cs` のメソッドシグネチャを変更
- `IImageResizeService.cs` のメソッドシグネチャを変更

#### Infrastructure層
- `FileSystemImageRepository.cs` を例外駆動からResult駆動に変更
- `ImageResizeService.cs` を例外駆動からResult駆動に変更

#### Application層
- `ResizeImageUseCase.cs` を例外駆動からResult駆動に変更
- `ValidateRequest` メソッドもResultを返すように変更

#### Presentation層
- `ImageController.cs` の例外処理を削除（115行 → 55行、約50%削減）
- エラーコードベースのswitch式でHTTPステータスを決定

### 12.8 パフォーマンスへの影響

Resultパターンの導入により、以下のパフォーマンス改善が期待されます：

1. **例外のオーバーヘッド削減**: 正常な異常系（ファイルが見つからない等）で例外を使用しないため、スタックトレース生成コストを削減
2. **メモリ使用量の削減**: 例外オブジェクトの生成とスタックトレース保持が不要
3. **予測可能なパフォーマンス**: 例外パスと正常パスの性能差が小さくなる

### 12.9 移行のベストプラクティス

今後、新しい機能を追加する際のガイドライン：

1. **ビジネスロジックのエラー**: Resultパターンを使用
2. **予期されるエラー**: Resultパターンを使用（ファイルが見つからない、バリデーションエラーなど）
3. **予期しないエラー**: 例外を使用し、UseCase層でResultに変換
4. **ログ記録**: エラー発生時は必ずログを記録（Result失敗時も同様）

---

## 13. テスト方針

### 12.1 エラーハンドリングのテスト

エラーハンドリングのテストでは、以下のケースをカバーします：

1. **各エラーコードのテスト**: すべてのエラーコードが正しく返されることを確認
2. **HTTPステータスコードのテスト**: エラーコードに応じた適切なHTTPステータスコードが返されることを確認
3. **エラーメッセージのテスト**: エラーメッセージが適切に生成されることを確認
4. **ログ出力のテスト**: エラー発生時にログが正しく記録されることを確認
5. **例外の伝播テスト**: 例外が適切に伝播されることを確認

### 12.2 テスト例

```csharp
[Fact]
public async Task ResizeImage_FileNotFound_Returns404()
{
    // Arrange
    var request = new ResizeImageRequest
    {
        FilePath = "C:\\nonexistent.jpg"
    };

    // Act
    var result = await _controller.ResizeImage(request);

    // Assert
    var notFoundResult = Assert.IsType<NotFoundObjectResult>(result.Result);
    var response = Assert.IsType<ResizeImageResponse>(notFoundResult.Value);
    Assert.False(response.Success);
    Assert.Equal("FILE_NOT_FOUND", response.ErrorCode);
    Assert.Equal(404, notFoundResult.StatusCode);
}
```

---

## 14. 関連ドキュメント

- [要件定義書](./要件定義書.md) - エラーハンドリング要件（FR-006）
- [機能仕様書](./機能仕様書.md) - エラーハンドリング機能仕様（3.6節）
- [詳細設計書](./詳細設計書.md) - エラーハンドリング詳細設計（4節）
- [API仕様書](./API仕様書.md) - エラーコード一覧とエラーレスポンス形式
- [データ仕様書](./データ仕様書.md) - エラーレスポンスDTO定義

---

## 15. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|----------|--------|
| 1.0.0 | - | 初版作成 | - |
| 1.1.0 | 2025-12-01 | Resultパターンのセクションを追加 | AI Assistant |

---

## 付録A: エラーコードとHTTPステータスコードのマッピング

| エラーコード | HTTPステータスコード | 説明 |
|------------|---------------------|------|
| `FILE_NOT_FOUND` | 404 | ファイルが見つからない |
| `INVALID_FILE_FORMAT` | 400 | サポートされていない画像形式 |
| `FILE_TOO_LARGE` | 400 | ファイルサイズが大きすぎる |
| `INVALID_REQUEST` | 400 | リクエストが不正 |
| `FILE_READ_ERROR` | 500 | ファイル読み込みエラー |
| `FILE_WRITE_ERROR` | 500 | ファイル書き込みエラー |
| `INVALID_CONFIGURATION` | 500 | 設定ファイルが不正 |
| `IMAGE_LOAD_ERROR` | 500 | 画像の読み込みに失敗 |
| `IMAGE_PROCESSING_ERROR` | 500 | 画像処理エラー |
| `INTERNAL_SERVER_ERROR` | 500 | サーバー内部エラー |

---

## 付録B: エラーハンドリングチェックリスト

実装時に以下の項目を確認してください：

### 例外の定義
- [ ] すべてのカスタム例外クラスが定義されている
- [ ] 例外クラスが`ImageProcessingException`を継承している
- [ ] エラーコードが適切に設定されている

### 例外のスロー
- [ ] 適切なタイミングで例外がスローされている
- [ ] 例外メッセージが明確で分かりやすい
- [ ] 内部例外が適切に保持されている

### 例外のキャッチ
- [ ] すべての例外が適切にキャッチされている
- [ ] エラーレスポンスが正しく生成されている
- [ ] HTTPステータスコードが適切に設定されている

### ログ記録
- [ ] すべてのエラーがログに記録されている
- [ ] ログレベルが適切に設定されている
- [ ] 構造化ログが使用されている

### テスト
- [ ] すべてのエラーケースがテストされている
- [ ] エラーレスポンスが正しく返されることを確認
- [ ] ログが正しく記録されることを確認

