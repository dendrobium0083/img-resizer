# 詳細設計書

## 文書情報

| 項目 | 内容 |
|------|------|
| 文書名 | 詳細設計書 |
| プロジェクト名 | img-resizer |
| バージョン | 1.0.0 |
| 作成日 | 2024年 |
| 最終更新日 | 2024年 |
| 作成者 | - |
| 承認者 | - |
| 関連ドキュメント | [基本設計書](./基本設計書.md), [機能仕様書](./機能仕様書.md), [API仕様書](./API仕様書.md), [データ仕様書](./データ仕様書.md) |

---

## 1. 概要

### 1.1 目的
このドキュメントは、img-resizerプロジェクトの詳細な実装設計を定義します。クラス設計、インターフェース定義、アルゴリズム詳細、実装方針を記載します。

### 1.2 対象読者
- 開発者
- コードレビュアー
- テスター

---

## 2. クラス設計

### 2.1 Domain層

#### 2.1.1 ImageFile エンティティ

**名前空間**: `ImgResizer.Domain.Entities`

**定義**:
```csharp
namespace ImgResizer.Domain.Entities;

public class ImageFile
{
    public string FilePath { get; set; } = string.Empty;
    public string FileName { get; set; } = string.Empty;
    public string Extension { get; set; } = string.Empty;
    public long FileSize { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

**責務**:
- 画像ファイルの情報を保持
- ビジネスルールの実装

#### 2.1.2 IImageRepository インターフェース

**名前空間**: `ImgResizer.Domain.Interfaces`

**定義**:
```csharp
namespace ImgResizer.Domain.Interfaces;

public interface IImageRepository
{
    Task<byte[]> ReadImageAsync(string filePath);
    Task SaveImageAsync(string filePath, byte[] imageData);
    bool FileExists(string filePath);
    string GetOutputPath(string inputPath, string outputDirectory);
}
```

**責務**:
- 画像ファイルの読み書き操作を定義
- ファイル存在確認
- 出力ファイルパスの生成

**メソッド詳細**:

| メソッド名 | 戻り値 | 説明 |
|-----------|--------|------|
| ReadImageAsync | `Task<byte[]>` | 画像ファイルを非同期で読み込む |
| SaveImageAsync | `Task` | 画像データを非同期で保存する |
| FileExists | `bool` | ファイルの存在を確認する |
| GetOutputPath | `string` | 出力ファイルパスを生成する |

#### 2.1.3 IImageResizeService インターフェース

**名前空間**: `ImgResizer.Domain.Interfaces`

**定義**:
```csharp
namespace ImgResizer.Domain.Interfaces;

public interface IImageResizeService
{
    Task<byte[]> ResizeToSquareAsync(byte[] imageData, int size, string resizeMode);
    bool IsSupportedFormat(string filePath);
}
```

**責務**:
- 画像リサイズ処理を定義
- サポートされている画像形式の判定

**メソッド詳細**:

| メソッド名 | 戻り値 | 説明 |
|-----------|--------|------|
| ResizeToSquareAsync | `Task<byte[]>` | 画像を正方形にリサイズする（非同期） |
| IsSupportedFormat | `bool` | サポートされている画像形式か判定する |

**パラメータ**:
- `imageData`: 元画像データ（バイト配列）
- `size`: ターゲットサイズ（512）
- `resizeMode`: 変換方式（`"fit"` または `"crop"`）

### 2.2 Application層

#### 2.2.1 ResizeImageRequest DTO

**名前空間**: `ImgResizer.Application.DTOs`

**定義**:
```csharp
namespace ImgResizer.Application.DTOs;

public class ResizeImageRequest
{
    public string FilePath { get; set; } = string.Empty;
    public string? ResizeMode { get; set; }
}
```

**責務**:
- APIリクエストデータを保持
- バリデーション対象

#### 2.2.2 ResizeImageResponse DTO

**名前空間**: `ImgResizer.Application.DTOs`

**定義**:
```csharp
namespace ImgResizer.Application.DTOs;

public class ResizeImageResponse
{
    public bool Success { get; set; }
    public string Message { get; set; } = string.Empty;
    public string? OutputPath { get; set; }
    public string? ResizeMode { get; set; }
    public string? ErrorCode { get; set; }
}
```

**責務**:
- APIレスポンスデータを保持
- 処理結果を返却

#### 2.2.3 ResizeImageUseCase

**名前空間**: `ImgResizer.Application.UseCases`

**定義**:
```csharp
namespace ImgResizer.Application.UseCases;

public class ResizeImageUseCase
{
    private readonly IImageRepository _imageRepository;
    private readonly IImageResizeService _imageResizeService;
    private readonly IOptions<ImageResizeSettings> _settings;
    private readonly ILogger<ResizeImageUseCase> _logger;

    public ResizeImageUseCase(
        IImageRepository imageRepository,
        IImageResizeService imageResizeService,
        IOptions<ImageResizeSettings> settings,
        ILogger<ResizeImageUseCase> logger)
    {
        _imageRepository = imageRepository;
        _imageResizeService = imageResizeService;
        _settings = settings;
        _logger = logger;
    }

    public async Task<ResizeImageResponse> ExecuteAsync(ResizeImageRequest request)
    {
        // 1. バリデーション
        // 2. ファイル存在確認
        // 3. 画像読み込み
        // 4. リサイズ処理（resizeModeに応じて）
        // 5. 保存
        // 6. レスポンス返却
    }
}
```

**責務**:
- 画像変換ユースケースの実装
- ビジネスロジックのオーケストレーション
- エラーハンドリング

### 2.3 Infrastructure層

#### 2.3.1 ImageResizeService 実装

**名前空間**: `ImgResizer.Infrastructure.Services`

**定義**:
```csharp
namespace ImgResizer.Infrastructure.Services;

public class ImageResizeService : IImageResizeService
{
    private readonly ILogger<ImageResizeService> _logger;

    public ImageResizeService(ILogger<ImageResizeService> logger)
    {
        _logger = logger;
    }

    public async Task<byte[]> ResizeToSquareAsync(byte[] imageData, int size, string resizeMode)
    {
        // System.Drawingを使用した実装
        // resizeModeに応じて処理を分岐
        // - "fit": 全体変換方式
        // - "crop": 中央クロップ方式
    }

    public bool IsSupportedFormat(string filePath)
    {
        // サポートされている拡張子かチェック
    }
}
```

**責務**:
- 画像リサイズ処理の実装
- System.Drawingライブラリの使用

#### 2.3.2 FileSystemImageRepository 実装

**名前空間**: `ImgResizer.Infrastructure.Repositories`

**定義**:
```csharp
namespace ImgResizer.Infrastructure.Repositories;

public class FileSystemImageRepository : IImageRepository
{
    private readonly IOptions<ImageResizeSettings> _settings;
    private readonly ILogger<FileSystemImageRepository> _logger;

    public FileSystemImageRepository(
        IOptions<ImageResizeSettings> settings,
        ILogger<FileSystemImageRepository> logger)
    {
        _settings = settings;
        _logger = logger;
    }

    public async Task<byte[]> ReadImageAsync(string filePath)
    {
        return await File.ReadAllBytesAsync(filePath);
    }

    public async Task SaveImageAsync(string filePath, byte[] imageData)
    {
        var directory = Path.GetDirectoryName(filePath);
        if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))
        {
            Directory.CreateDirectory(directory);
        }
        await File.WriteAllBytesAsync(filePath, imageData);
    }

    public bool FileExists(string filePath)
    {
        return File.Exists(filePath);
    }

    public string GetOutputPath(string inputPath, string outputDirectory)
    {
        var fileName = Path.GetFileNameWithoutExtension(inputPath);
        var extension = Path.GetExtension(inputPath);
        var resizeMode = // リクエストから取得
        var suffix = resizeMode == "crop" ? "_512x512_crop" : "_512x512";
        var outputFileName = $"{fileName}{suffix}{extension}";
        return Path.Combine(outputDirectory, outputFileName);
    }
}
```

**責務**:
- ファイルシステムへのアクセス実装
- 出力ファイルパスの生成

#### 2.3.3 ImageResizeSettings クラス

**名前空間**: `ImgResizer.Infrastructure.Configuration`

**定義**:
```csharp
namespace ImgResizer.Infrastructure.Configuration;

public class ImageResizeSettings
{
    public string InputDirectory { get; set; } = string.Empty;
    public string OutputDirectory { get; set; } = string.Empty;
    public TargetSizeSettings TargetSize { get; set; } = new();
    public string[] AllowedExtensions { get; set; } = Array.Empty<string>();
    public long MaxFileSize { get; set; } = 52428800; // 50MB
    public PaddingColorSettings? PaddingColor { get; set; }
    public ImageQualitySettings? ImageQuality { get; set; }
}

public class TargetSizeSettings
{
    public int Width { get; set; } = 512;
    public int Height { get; set; } = 512;
}

public class PaddingColorSettings
{
    public int R { get; set; } = 0;
    public int G { get; set; } = 0;
    public int B { get; set; } = 0;
    public int A { get; set; } = 255;
}

public class ImageQualitySettings
{
    public int JpegQuality { get; set; } = 90;
    public int PngCompressionLevel { get; set; } = 6;
}
```

**責務**:
- 設定データの保持
- 設定ファイルからの読み込み

### 2.4 Presentation層

#### 2.4.1 ImageController

**名前空間**: `ImgResizer.Api.Controllers`

**定義**:
```csharp
namespace ImgResizer.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class ImageController : ControllerBase
{
    private readonly ResizeImageUseCase _resizeImageUseCase;
    private readonly ILogger<ImageController> _logger;

    public ImageController(
        ResizeImageUseCase resizeImageUseCase,
        ILogger<ImageController> logger)
    {
        _resizeImageUseCase = resizeImageUseCase;
        _logger = logger;
    }

    [HttpPost("resize")]
    public async Task<ActionResult<ResizeImageResponse>> ResizeImage(
        [FromBody] ResizeImageRequest request)
    {
        try
        {
            _logger.LogInformation("画像変換リクエスト受信: {FilePath}, ResizeMode: {ResizeMode}", 
                request.FilePath, request.ResizeMode ?? "fit");
            
            var response = await _resizeImageUseCase.ExecuteAsync(request);
            
            if (response.Success)
            {
                _logger.LogInformation("画像変換処理完了: {OutputPath}", response.OutputPath);
                return Ok(response);
            }
            
            _logger.LogWarning("画像変換処理失敗: {ErrorCode}, {Message}", 
                response.ErrorCode, response.Message);
            return BadRequest(response);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "画像変換中にエラーが発生しました: {FilePath}", request.FilePath);
            return StatusCode(500, new ResizeImageResponse
            {
                Success = false,
                Message = "サーバーエラーが発生しました",
                ErrorCode = "INTERNAL_SERVER_ERROR"
            });
        }
    }
}
```

**責務**:
- HTTPリクエスト/レスポンスの処理
- ルーティング
- エラーハンドリング
- ロギング

---

## 3. 画像変換アルゴリズム詳細

### 3.1 全体変換方式（fit）のアルゴリズム

#### 3.1.1 処理手順

1. **元画像の読み込み**
   ```csharp
   using var originalImage = new Bitmap(new MemoryStream(imageData));
   ```

2. **アスペクト比の計算**
   ```csharp
   double aspectRatio = (double)originalImage.Width / originalImage.Height;
   ```

3. **リサイズサイズの決定**
   ```csharp
   int newWidth, newHeight;
   if (originalImage.Width > originalImage.Height)
   {
       newWidth = 512;
       newHeight = (int)(512 / aspectRatio);
   }
   else
   {
       newHeight = 512;
       newWidth = (int)(512 * aspectRatio);
   }
   ```

4. **リサイズ処理**
   ```csharp
   using var resizedImage = new Bitmap(newWidth, newHeight);
   using (var graphics = Graphics.FromImage(resizedImage))
   {
       graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
       graphics.DrawImage(originalImage, 0, 0, newWidth, newHeight);
   }
   ```

5. **正方形キャンバスの作成**
   ```csharp
   using var squareCanvas = new Bitmap(512, 512);
   using (var graphics = Graphics.FromImage(squareCanvas))
   {
       // パディング色で塗りつぶし
       var paddingColor = Color.FromArgb(
           settings.PaddingColor?.A ?? 255,
           settings.PaddingColor?.R ?? 0,
           settings.PaddingColor?.G ?? 0,
           settings.PaddingColor?.B ?? 0);
       graphics.Clear(paddingColor);
       
       // 中央配置
       int x = (512 - newWidth) / 2;
       int y = (512 - newHeight) / 2;
       graphics.DrawImage(resizedImage, x, y, newWidth, newHeight);
   }
   ```

6. **画像データの変換**
   ```csharp
   using var memoryStream = new MemoryStream();
   squareCanvas.Save(memoryStream, GetImageFormat(extension));
   return memoryStream.ToArray();
   ```

### 3.2 中央クロップ方式（crop）のアルゴリズム

#### 3.2.1 処理手順

1. **元画像の読み込み**
   ```csharp
   using var originalImage = new Bitmap(new MemoryStream(imageData));
   ```

2. **クロップサイズの決定**
   ```csharp
   int cropSize = Math.Min(originalImage.Width, originalImage.Height);
   
   // 元画像が512×512より小さい場合は、そのまま拡大
   if (originalImage.Width < 512 || originalImage.Height < 512)
   {
       // 拡大処理（クロップなし）
       return ResizeImageDirectly(originalImage, 512);
   }
   ```

3. **中央位置の計算**
   ```csharp
   int x = (originalImage.Width - cropSize) / 2;
   int y = (originalImage.Height - cropSize) / 2;
   ```

4. **中央部分の切り出し**
   ```csharp
   var cropRect = new Rectangle(x, y, cropSize, cropSize);
   using var croppedImage = originalImage.Clone(cropRect, originalImage.PixelFormat);
   ```

5. **リサイズ処理**
   ```csharp
   using var resizedImage = new Bitmap(512, 512);
   using (var graphics = Graphics.FromImage(resizedImage))
   {
       graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
       graphics.DrawImage(croppedImage, 0, 0, 512, 512);
   }
   ```

6. **画像データの変換**
   ```csharp
   using var memoryStream = new MemoryStream();
   resizedImage.Save(memoryStream, GetImageFormat(extension));
   return memoryStream.ToArray();
   ```

### 3.3 画像形式の判定

```csharp
private ImageFormat GetImageFormat(string extension)
{
    return extension.ToLower() switch
    {
        ".jpg" or ".jpeg" => ImageFormat.Jpeg,
        ".png" => ImageFormat.Png,
        ".gif" => ImageFormat.Gif,
        ".bmp" => ImageFormat.Bmp,
        _ => ImageFormat.Png
    };
}
```

---

## 4. エラーハンドリング詳細

### 4.1 カスタム例外クラス

**名前空間**: `ImgResizer.Domain.Exceptions`

```csharp
namespace ImgResizer.Domain.Exceptions;

public class ImageProcessingException : Exception
{
    public string ErrorCode { get; }

    public ImageProcessingException(string errorCode, string message) 
        : base(message)
    {
        ErrorCode = errorCode;
    }
}

public class FileNotFoundException : ImageProcessingException
{
    public FileNotFoundException(string filePath) 
        : base("FILE_NOT_FOUND", $"ファイルが見つかりません: {filePath}")
    {
    }
}

public class UnsupportedFormatException : ImageProcessingException
{
    public UnsupportedFormatException(string extension) 
        : base("INVALID_FILE_FORMAT", $"サポートされていない画像形式です: {extension}")
    {
    }
}

public class FileTooLargeException : ImageProcessingException
{
    public FileTooLargeException(long fileSize, long maxSize) 
        : base("FILE_TOO_LARGE", $"ファイルサイズが大きすぎます。現在: {fileSize}バイト、最大: {maxSize}バイト")
    {
    }
}

public class ValidationException : ImageProcessingException
{
    public ValidationException(string message) 
        : base("INVALID_REQUEST", message)
    {
    }
}
```

### 4.2 例外処理の実装方針

1. **Domain層**: カスタム例外を定義
2. **Application層**: カスタム例外をスロー
3. **Presentation層**: 例外をキャッチしてHTTPレスポンスに変換

**例外処理フロー**:
```
[Domain/Application層]
  |
  | カスタム例外をスロー
  |
  v
[Presentation層]
  |
  | 例外をキャッチ
  |
  v
[エラーレスポンス生成]
  |
  | HTTPステータスコード + エラーレスポンス
  |
  v
[Client]
```

---

## 5. 設定ファイルの詳細

### 5.1 appsettings.json（完全版）

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "ImgResizer": "Debug"
    }
  },
  "AllowedHosts": "*",
  "ImageResize": {
    "InputDirectory": "C:\\images\\input",
    "OutputDirectory": "C:\\images\\output",
    "TargetSize": {
      "Width": 512,
      "Height": 512
    },
    "AllowedExtensions": [".jpg", ".jpeg", ".png", ".gif", ".bmp"],
    "MaxFileSize": 52428800,
    "PaddingColor": {
      "R": 0,
      "G": 0,
      "B": 0,
      "A": 255
    },
    "ImageQuality": {
      "JpegQuality": 90,
      "PngCompressionLevel": 6
    }
  }
}
```

### 5.2 appsettings.Development.json

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Debug",
      "Microsoft.AspNetCore": "Information"
    }
  },
  "ImageResize": {
    "InputDirectory": "C:\\dev\\images\\input",
    "OutputDirectory": "C:\\dev\\images\\output"
  }
}
```

### 5.3 設定項目の説明

| 設定項目 | 型 | デフォルト値 | 説明 |
|---------|-----|------------|------|
| `InputDirectory` | `string` | - | 入力画像ファイルのディレクトリパス |
| `OutputDirectory` | `string` | - | 出力画像ファイルのディレクトリパス |
| `TargetSize.Width` | `int` | 512 | ターゲットサイズの幅（ピクセル） |
| `TargetSize.Height` | `int` | 512 | ターゲットサイズの高さ（ピクセル） |
| `AllowedExtensions` | `string[]` | `[".jpg", ".jpeg", ".png", ".gif", ".bmp"]` | 許可された画像拡張子のリスト |
| `MaxFileSize` | `long` | 52428800 (50MB) | 最大ファイルサイズ（バイト） |
| `PaddingColor.R` | `int` | 0 | パディング色の赤成分（0-255） |
| `PaddingColor.G` | `int` | 0 | パディング色の緑成分（0-255） |
| `PaddingColor.B` | `int` | 0 | パディング色の青成分（0-255） |
| `PaddingColor.A` | `int` | 255 | パディング色の透明度（0-255） |
| `ImageQuality.JpegQuality` | `int` | 90 | JPEG品質（1-100） |
| `ImageQuality.PngCompressionLevel` | `int` | 6 | PNG圧縮レベル（0-9） |

---

## 6. 依存性注入（DI）の設定

### 6.1 Program.cs の設定

```csharp
var builder = WebApplication.CreateBuilder(args);

// 設定の読み込み
builder.Services.Configure<ImageResizeSettings>(
    builder.Configuration.GetSection("ImageResize"));

// サービスの登録
builder.Services.AddScoped<IImageRepository, FileSystemImageRepository>();
builder.Services.AddScoped<IImageResizeService, ImageResizeService>();
builder.Services.AddScoped<ResizeImageUseCase>();

// コントローラー
builder.Services.AddControllers();

// Swagger/OpenAPI
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// ミドルウェアの設定
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
```

### 6.2 サービスライフサイクル

| サービス | ライフサイクル | 理由 |
|---------|--------------|------|
| `IImageRepository` | Scoped | リクエストごとに新しいインスタンス |
| `IImageResizeService` | Scoped | リクエストごとに新しいインスタンス |
| `ResizeImageUseCase` | Scoped | リクエストごとに新しいインスタンス |
| `ImageResizeSettings` | Singleton | 設定はアプリケーション全体で共有 |

---

## 7. ロギング戦略

### 7.1 ログレベル

| レベル | 用途 | 出力内容 |
|--------|------|----------|
| Information | 正常な処理完了 | リクエスト受信、処理完了 |
| Warning | 警告 | 設定値のデフォルト使用、バリデーション警告 |
| Error | エラー | 例外発生、エラー詳細 |
| Debug | デバッグ情報 | 詳細な処理情報（開発環境のみ） |

### 7.2 ログ出力箇所

1. **リクエスト受信時**
   ```csharp
   _logger.LogInformation("画像変換リクエスト受信: {FilePath}, ResizeMode: {ResizeMode}", 
       request.FilePath, request.ResizeMode ?? "fit");
   ```

2. **処理開始時**
   ```csharp
   _logger.LogDebug("画像変換処理開始: {FilePath}", request.FilePath);
   ```

3. **処理完了時**
   ```csharp
   _logger.LogInformation("画像変換処理完了: {OutputPath}, ResizeMode: {ResizeMode}", 
       response.OutputPath, response.ResizeMode);
   ```

4. **エラー発生時**
   ```csharp
   _logger.LogError(ex, "画像変換中にエラーが発生: {FilePath}, ErrorCode: {ErrorCode}", 
       request.FilePath, errorCode);
   ```

### 7.3 ログ設定

**appsettings.json**:
```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "ImgResizer": "Debug"
    }
  }
}
```

---

## 8. パフォーマンス考慮事項

### 8.1 非同期処理

- すべてのI/O操作は非同期で実行
- `async/await`パターンを使用
- ブロッキング操作を避ける

### 8.2 メモリ管理

- `using`ステートメントでリソースを適切に解放
- `IDisposable`を実装するオブジェクトは必ず`using`で囲む
- 大きな画像の場合はストリーミング処理を検討

**例**:
```csharp
using var originalImage = new Bitmap(new MemoryStream(imageData));
using var resizedImage = new Bitmap(512, 512);
// 処理...
// 自動的にリソースが解放される
```

### 8.3 画像処理の最適化

- 高品質リサンプリングアルゴリズムを使用（`HighQualityBicubic`）
- メモリ効率を考慮した処理
- 大きな画像の場合は段階的なリサイズを検討

### 8.4 キャッシュ（将来の拡張）

- 変換済み画像のキャッシュ
- メモリキャッシュまたはファイルキャッシュ
- キャッシュキー: ファイルパス + 変換方式

---

## 9. セキュリティ考慮事項

### 9.1 ファイルパスの検証

**パストラバーサル攻撃の防止**:
```csharp
// 危険な文字列のチェック
if (filePath.Contains("..") || filePath.Contains("~"))
{
    throw new ValidationException("無効なファイルパスです");
}

// パスの正規化
var normalizedPath = Path.GetFullPath(filePath);
```

### 9.2 ファイルサイズ制限

```csharp
var fileInfo = new FileInfo(filePath);
if (fileInfo.Length > settings.MaxFileSize)
{
    throw new FileTooLargeException(fileInfo.Length, settings.MaxFileSize);
}
```

### 9.3 拡張子の検証

```csharp
var extension = Path.GetExtension(filePath).ToLower();
if (!settings.AllowedExtensions.Contains(extension))
{
    throw new UnsupportedFormatException(extension);
}
```

### 9.4 入力検証

- リクエストのバリデーションを徹底
- ファイルパスの正規化
- 拡張子のホワイトリスト検証

---

## 10. 関連ドキュメント

- [基本設計書](./基本設計書.md)
- [機能仕様書](./機能仕様書.md)
- [API仕様書](./API仕様書.md)
- [データ仕様書](./データ仕様書.md)
- [要件定義書](./要件定義書.md)

---

## 11. 変更履歴

| バージョン | 日付 | 変更内容 | 変更者 |
|-----------|------|----------|--------|
| 1.0.0 | - | 初版作成 | - |

